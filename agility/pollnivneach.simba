program pollnivneach;
{$DEFINE SRL_USE_REMOTEINPUT}
{$I WaspLib/osr.simba}
{$DEFINE FORMS_V2}

begin
  Login.PlayerIndex := 1;
end;

var
  Food: TRSItem := 'Lobster';
  HpToEatAt: Int32 := 8;
  StartTileArray: TPointArray := [[1430, 236], [1434, 236], [1438, 236], [1442, 236],
                                  [1430, 240], [1434, 240], [1438, 240], [1442, 240]];
  RSW: TRSWalker;
  Step: Int32;
  Timer: TStopwatch;
  StartXP: Int32;
  CurrentXP: Int32;
  GainedXP: Int32 := 0;
  HLColor: TCTS2Color :=  CTS2(3324770, 19, 0.25, 1.25);
  ObstacleArray: TPointArray := [[1426, 240], [1426, 240], [1286, 520],
                                 [1316, 490], [1342, 490],
                                 [1362, 490],  [1350, 468],
                                 [1166, 726], [1174, 678], [1186, 658]];
  AreaArray: TBoxArray := [[1466, 88, 1488, 104], // course ending tiles
                           [1330, 10, 1555, 300], // whole city
                           [1265, 520, 1303, 553],
                           [1294, 489, 1318, 515],
                           [1324, 477, 1345, 496],
                           [1350, 489, 1379, 513],
                           [1342, 458, 1375, 477],
                           [1146, 716, 1199, 753],
                           [1150, 674, 1225, 715],
                           [1145, 637, 1195, 671]];

procedure PauseTimer(Task: PBreakTask);
var T: PBreakTask;
begin
  Timer.Pause;
  T := Task;
end;

procedure ResumeTimer(Task: PBreakTask);
var T: PBreakTask;
begin
  Timer.Resume;
  T := Task;
end;

procedure PrintProgress();
begin
  ClearDebug();
  WriteLn("| ~   pollnivneach hopper v0.01   ~ |");
  WriteLn('| ----------------------------------|');
  WriteLn('| Time running   : ', SRL.MsToTime(GetTimeRunning, Time_Short));
  WriteLn('| Agility exp    : ', GainedXP);
  WriteLn('| Failsafe timer : ', SRL.MsToTime((300000-Timer.ElapsedTime), Time_Short));
  WriteLn('| Next break     : ', Antiban.TimeUntilBreak(Antiban.Breaks[0]));
  WriteLn('| ----------------------------------|');
end;

// A custom Keyboard version of Antiban.RandomRotate()
// Rotating with mouse3 doesn't work well with RuneLite
procedure KeyboardRotate();
var
  Arrow: Integer;
  Duration: Int64;
begin
  if SRL.Dice(50) then
    Arrow := $25
  else
    Arrow := $27;
  Duration := SRL.NormalRange(500, 1500);
  Keyboard.KeyDown(Arrow);
  Sleep(Duration);
  Keyboard.KeyUp(Arrow);
end;

procedure TAntiban.DoLoseFocus();
Var T: Int32;
begin
  T := SRL.NormalRange(800,3500);
  Self.DebugLn('Losing focus for '+SRL.MsToTime(T, Time_Short));
  Self.LoseFocus(T);
end;

procedure SetupAntiBan();
begin
  Antiban.Skills := [ERSSKILL.AGILITY, ERSSKILL.TOTAL];

  Antiban.AddTask(ONE_MINUTE*2,   @Mouse.RandomMovement);
  Antiban.AddTask(ONE_MINUTE*5,   @Antiban.HoverMSPlayers);
  Antiban.AddTask(ONE_MINUTE*3,   @Antiban.DoLoseFocus);
  Antiban.AddTask(ONE_MINUTE*7,   @KeyboardRotate);
  Antiban.AddTask(ONE_MINUTE*8,   @Antiban.HoverMSNPCs);
  Antiban.AddTask(ONE_MINUTE*25,  @Antiban.HoverSkills);
  Antiban.AddBreak(ONE_MINUTE * 5, ONE_SECOND*10, 0.2, 0);
  Antiban.AddBreak(33 * ONE_MINUTE, 9 * ONE_MINUTE);
  Antiban.AddBreak(10 * ONE_HOUR, 8 * ONE_HOUR);
  Antiban.OnStartBreak := @PauseTimer;
  Antiban.OnFinishBreak := @ResumeTimer;
end;

procedure InitiateScript();
begin
  RSW.Setup('agility');
  RSGroundItems.Setup();
  SetupAntiBan();
  if not RSClient.IsLoggedIn() then Login.LoginPlayer();
  WaitUntil(RSClient.IsLoggedIn(), 100, 10000);
  StartXP := XPBar.Read();
  Timer.Start();
end;

procedure CalculateXP();
var t: Int32;
begin
  CurrentXP := XPBar.Read();
  t         := GainedXP;
  GainedXP  := CurrentXP - StartXP;
  if GainedXP > t then Timer.Reset();
  if Timer.ElapsedTime > 300000 then TerminateScript('No Gained XP in 5 minutes!')
end;

function GetStep(): Int32;
var
  pos: TPoint;
  i: Int32;
begin
  pos := RSW.GetMyPos();
  for i := 0 to High(AreaArray) do
    if AreaArray[i].Contains(pos) then Exit(i);
  Exit(-1);
end;

procedure StartStep();
var
  Pt: TPoint;
  Rect: TRectangle;
  TPA: TPointArray;
  XP: Int32;
  GoalTile: TPoint;
  CurrentTile: TPoint;
  Path: TPointArray;
  tb: TBox;
begin
  CalculateXP();
  PrintProgress();
  CurrentTile := RSW.GetMyPos();
  GoalTile := StartTileArray.RandomValue();
  Path := [[1470, 108], [1474, 152], [1474, 192], [1454, 220], [1442, 240], GoalTile];
  RSW.WalkPath(Path);
  Rect := RSW.GetTileMs(ObstacleArray[0]);
  tb := Rect.Bounds();
  tb.LimitTo(Mainscreen.Bounds());
  SRL.FindColors(TPA, HLColor, tb);
  if TPA.Len() > 0 then
  begin
    XP := XPBar.Read();
    Pt := SRL.rowp(TPA.Mean(), TPA.Bounds());
    Mouse.HumanMove(Pt);
    WaitEx(120, 25);
    if MainScreen.IsUpText('Climb') then
      begin
        Mouse.Click(MOUSE_LEFT);
        WaitUntil(XPBar.Read > XP, 200, 10000);
        WaitEx(550, 25);
        Exit();
      end
    else KeyboardRotate();
    WriteLn('Unable to find next obstacle!');
    Exit();
  end;
end;

procedure NormalStep(Step: Int32);
var
  Pt: TPoint;
  Rect: TRectangle;
  TPA: TPointArray;
  XP: Int32;
  graceATPA: T2DPointArray;
  GoalTile: TPoint;
  tb: TBox;
begin
  GoalTile := StartTileArray.RandomValue();

  if Step = 1 then
    RSW.WalkBlind(GoalTile);


  // pollnivneach course start room has items on ground and similar colored windows to mog
  if Step > 1 then
    begin
      RSGroundItems.MarkOfGrace.Find(graceATPA);
      if RSGroundItems.MarkOfGrace.Find(graceATPA) then
        if AreaArray[Step].Contains(RSGroundItems.MarkOfGrace.ClosestDot) then
          begin
            RSGroundItems.MarkOfGrace.Click(true, 1);
            Wait(2000, 2500);
          end;
    end;

  Rect := RSW.GetTileMs(ObstacleArray[Step]);
  Rect := Rect.Expand(30);
  tb := Rect.Bounds();
  tb.LimitTo(Mainscreen.Bounds());
  SRL.FindColors(TPA, HLColor, tb);
  if TPA.Len() > 0 then
  begin
    XP := XPBar.Read();
    Pt := SRL.rowp(TPA.Mean(), TPA.Bounds());
    Mouse.HumanMove(Pt);
    WaitEx(125, 25);
    if MainScreen.IsUpText(['Climb', 'Jump', 'Grab', 'Balance', 'Cross', 'Leap', 'Hurdle', 'Vault', 'Jump-off']) then
      begin
        Mouse.Click(MOUSE_LEFT);
        WaitUntil(((XPBar.Read > XP) or AreaArray[1].Contains(RSW.GetMyPos())), 200, 10000);
        WaitEx(150, 25);
        Exit();
      end
    else KeyboardRotate();
    WriteLn('Unable to find next obstacle!');
    Exit();
  end
  else KeyboardRotate();
end

begin
  InitiateScript();
  repeat
    begin
      CalculateXP();
      Antiban.DoAntiban();
      if not RSClient.IsLoggedIn() then Login.LoginPlayer();
      Step := GetStep();
      if Minimap.GetHPLevel < HpToEatAt then Inventory.ClickItem(Food);
      if Step < 0 then WriteLn('Unknown Step!');
      if Step = 0 then StartStep();
      if Step > 0 then NormalStep(Step);
      WaitEx(250, 25);
    end;
  until false;
end.
